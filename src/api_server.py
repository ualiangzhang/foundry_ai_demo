#!/usr/bin/env python3
"""
src/api_server.py

Minimal REST API for:
  • Startup Evaluation  → /evaluate
  • Web QA              → /qa

Both endpoints return JSON and rely on the chain builders defined in src/rag/chains.py.

Run locally:
---------------
# Activate your virtual environment first:
uvicorn src.api_server:app --host 0.0.0.0 --port 8000

Test endpoints:
---------------
curl -X POST http://localhost:8000/evaluate \
     -H "Content-Type: application/json" \
     -d '{"summary": "Develop a VR fitness platform ..."}'

curl -X POST http://localhost:8000/qa \
     -H "Content-Type: application/json" \
     -d '{"question": "What is CRISPR gene editing?"}'
"""

from __future__ import annotations

import logging
from pathlib import Path
from typing import Callable, Dict, Any

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

# Ensure local package imports work
import sys

PROJECT_ROOT: Path = Path(__file__).resolve().parent
sys.path.insert(0, str(PROJECT_ROOT))

from src.rag.chains import build_chain  # noqa: E402

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)

# Build chains once at startup (thread-safe, read-only afterward)
EVAL_CHAIN: Callable[[Dict[str, str]], Dict[str, Any]] = build_chain(kind="eval", store="chroma")
QA_CHAIN: Callable[[Dict[str, str]], Dict[str, Any]] = build_chain(kind="qa", store="chroma")

app: FastAPI = FastAPI(
    title="Startup Evaluator & Web QA API",
    description="Thin wrapper around local LLaMA-3 evaluation and SerpApi-powered QA.",
    version="1.0.0",
)


class EvaluateRequest(BaseModel):
    """Request schema for the /evaluate endpoint.

    Attributes:
        summary (str): A concise startup summary provided by the user.
    """
    summary: str


class EvaluateResponse(BaseModel):
    """Response schema for the /evaluate endpoint.

    Attributes:
        result (str): Four VC-style recommendation bullets as a single string.
        context (str): Generated market context (~100 words).
        snippet (str): Concatenated market snippet(s) fetched from SerpApi.
        docs (list[str]): Three similar startup examples retrieved from the vector store.
    """
    result: str
    context: str
    snippet: str
    docs: list[str]


class QARequest(BaseModel):
    """Request schema for the /qa endpoint.

    Attributes:
        question (str): A factual question provided by the user.
    """
    question: str


class QAResponse(BaseModel):
    """Response schema for the /qa endpoint.

    Attributes:
        answer (str): The concise answer generated by ChatGPT-4o-mini.
        context (str): Concatenated web snippets retrieved from SerpApi.
    """
    answer: str
    context: str


@app.post("/evaluate", response_model=EvaluateResponse)
def evaluate(req: EvaluateRequest) -> EvaluateResponse:
    """Evaluate a startup idea and return market context + 4 VC recommendations.

    This endpoint performs the following steps:
      1. Validates that the 'summary' field is non-empty.
      2. Invokes the pre-built EVAL_CHAIN with the startup summary.
      3. Returns a JSON payload matching EvaluateResponse schema.

    Args:
        req (EvaluateRequest): The request body containing 'summary'.

    Returns:
        EvaluateResponse: The evaluation results including 'result', 'context',
                          'snippet', and 'docs'.

    Raises:
        HTTPException: If 'summary' is empty (400) or evaluation fails (500).
    """
    summary: str = req.summary.strip()
    if not summary:
        raise HTTPException(status_code=400, detail="Summary must not be empty.")

    try:
        output: Dict[str, Any] = EVAL_CHAIN({"question": summary})
        return EvaluateResponse(**output)
    except Exception as exc:  # noqa: BLE001
        logging.exception("Evaluation failed: %s", exc)
        raise HTTPException(status_code=500, detail=str(exc))


@app.post("/qa", response_model=QAResponse)
def qa(req: QARequest) -> QAResponse:
    """Answer a factual question using web snippets + GPT-4o-mini.

    This endpoint performs the following steps:
      1. Validates that the 'question' field is non-empty.
      2. Invokes the pre-built QA_CHAIN with the user question.
      3. Returns a JSON payload matching QAResponse schema.

    Args:
        req (QARequest): The request body containing 'question'.

    Returns:
        QAResponse: The QA results including 'answer' and 'context'.

    Raises:
        HTTPException: If 'question' is empty (400) or QA generation fails (500).
    """
    question: str = req.question.strip()
    if not question:
        raise HTTPException(status_code=400, detail="Question must not be empty.")

    try:
        output: Dict[str, Any] = QA_CHAIN({"question": question})
        return QAResponse(**output)
    except Exception as exc:  # noqa: BLE001
        logging.exception("QA failed: %s", exc)
        raise HTTPException(status_code=500, detail=str(exc))
