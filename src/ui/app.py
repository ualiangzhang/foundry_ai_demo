# src/ui/app.py

import os

# ── Workaround to prevent Streamlit’s file-watcher from inspecting torch internals ──
# This tells Streamlit to ignore any module paths that contain “torch” when watching for file changes.
os.environ["STREAMLIT_WATCHDOG_IGNORE_DIRS"] = "torch"

import logging
import sys
from pathlib import Path
from typing import Any, Dict, List

import streamlit as st

PROJECT_ROOT: Path = Path(__file__).resolve().parent.parent.parent  # type: ignore
sys.path.insert(0, str(PROJECT_ROOT))

from src.rag.chains import build_chain  # noqa: E402


# ── Configure module-level logger ─────────────────────────────────────────────
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)
logger = logging.getLogger(__name__)


@st.cache_resource
def get_chains() -> Dict[str, Any]:
    """
    Initialize and cache three chain variants: 'eval', 'pitch', and 'rag'.

    Returns:
        A dictionary mapping:
        - "eval" to a callable that performs DuckDuckGo + LLaMA-3 → VC recommendations.
        - "pitch" to a RetrievalQA chain for generating pitch-deck bullets.
        - "rag" to a RetrievalQA chain for generic RAG QA.
    """
    eval_chain = build_chain(kind="eval", store="chroma")
    pitch_chain = build_chain(kind="pitch", store="chroma")
    rag_chain = build_chain(kind="rag", store="chroma")
    return {"eval": eval_chain, "pitch": pitch_chain, "rag": rag_chain}


chains: Dict[str, Any] = get_chains()

# Create Streamlit tabs for the three functionalities
tab1, tab2, tab3 = st.tabs(["Evaluator", "Pitch-deck", "Generic RAG"])


# ─────────────────────────── Tab 1: Evaluator ────────────────────────────────
with tab1:
    st.header("Startup Evaluator")

    summ: str = st.text_area(
        label="Enter your startup summary (idea)",
        height=100,
        key="evaluator_summary",
    )

    if st.button("Evaluate Startup", key="evaluate_button"):
        if not summ.strip():
            st.error("Please enter a non-empty startup summary.")
        else:
            try:
                # The eval chain expects a dict with "question": summary
                eval_input: Dict[str, str] = {"question": summ}
                out: Dict[str, Any] = chains["eval"](eval_input)

                # 1. Display top-3 retrieved documents, if any
                docs: List[str] = out.get("docs", [])
                st.subheader("Top-3 Retrieved Documents")
                if docs:
                    for idx, doc_text in enumerate(docs, start=1):
                        # Flatten newlines for readability
                        safe_text: str = doc_text.strip().replace("\n", " ")
                        st.markdown(f"**Doc {idx}:** {safe_text}")
                else:
                    st.info("No documents retrieved for this summary.")

                # 2. Display the DuckDuckGo snippet (numeric fact), if available
                snippet: str = out.get("snippet", "")
                st.subheader("Market Snippet")
                if snippet:
                    st.write(snippet)
                else:
                    st.info("No snippet with numeric data found.")

                # 3. Display the ~100-word market context, if generated
                context: str = out.get("context", "")
                st.subheader("Market Context (~100 words)")
                if context:
                    st.write(context)
                else:
                    st.info("No context generated by the model.")

                # 4. Display the four VC recommendations
                recommendations: str = out.get("result", "")
                st.subheader("VC Recommendations")
                if recommendations:
                    st.write(recommendations)
                else:
                    st.info("No recommendations generated by the model.")

            except Exception as e:
                logger.error(f"Evaluator chain failed: {e}")
                st.error(f"Evaluation failed: {e}")


# ──────────────────────── Tab 2: Pitch-deck ─────────────────────────────────
with tab2:
    st.header("Pitch Deck Generator")

    summ_deck: str = st.text_area(
        label="Enter your startup summary for deck generation",
        height=100,
        key="pitch_deck_summary",
    )

    if st.button("Generate Pitch Deck", key="deck_button"):
        if not summ_deck.strip():
            st.error("Please enter a non-empty summary for pitch deck.")
        else:
            try:
                pitch_chain: Any = chains["pitch"]
                # Try the .run() API; if it fails, fall back to dict input
                try:
                    deck_output: str = pitch_chain.run(summ_deck)  # type: ignore
                except Exception:
                    deck_output = pitch_chain({"query": summ_deck})  # type: ignore

                st.subheader("Pitch Deck Bullets")
                if deck_output:
                    st.write(deck_output)
                else:
                    st.info("No output generated for pitch deck.")

            except Exception as e:
                logger.error(f"Pitch-deck chain failed: {e}")
                st.error(f"Pitch-deck generation failed: {e}")


# ─────────────────────────── Tab 3: Generic RAG ───────────────────────────────
with tab3:
    st.header("Generic RAG QA")

    question: str = st.text_input(
        label="Ask any question about your startup or market",
        key="rag_question",
    )

    if st.button("Get Answer", key="rag_button"):
        if not question.strip():
            st.error("Please enter a non-empty question.")
        else:
            try:
                rag_chain: Any = chains["rag"]
                # First try the .run() API; fallback to dict input if needed
                try:
                    answer: str = rag_chain.run(question)  # type: ignore
                except Exception:
                    answer = rag_chain({"query": question})  # type: ignore

                st.subheader("Answer")
                if answer:
                    st.write(answer)
                else:
                    st.info("No answer returned by the model.")

            except Exception as e:
                logger.error(f"RAG chain failed: {e}")
                st.error(f"RAG query failed: {e}")
